(def q
  (fx _ (p) p))

(def qs
  (fx _ p p))

(def id
  (wrap q))

(def list
  (wrap qs))

(def comment
  (fx _ p nil))

(def env
  (fx e _ e))

(def apply
  (wrap
   (fx _ (o as)
     (eval (env) (cons (unwrap o) as)))))

(def list*
  (wrap
   (fx _ (a . as)
     (if
       (nil? as) a
       (cons a (apply list* as))))))

(def fn
  (fx e (as . bs)
    (wrap (eval e (list* fx _ as bs)))))

(def defx
  (fx e (n e1 as . bs)
    (eval e
      (list def n (list* fx e1 as bs)))))

(def defn
  (fx e (n as . bs)
    (eval e
      (list def n (list* fn as bs)))))

(defn fold
    (f i as)
  (if
   (nil? as) i
   (fold f (f i (car as)) (cdr as))))

(defn conc2
    (as bs)
  (if
   (pair? as) (cons (car as) (conc2 (cdr as) bs))
   (nil? as) bs))

(defn conc
    as
  (fold conc2 nil as))

(defn part
    (f . as)
  (fn bs (apply f (conc as bs))))

(defn flip
    (f)
  (fn (a b . as) (apply f (list* b a as))))

(defn foldr
    (f as i)
  (if
   (nil? as) i
   (f (car as) (foldr f (cdr as) i))))

(defn rev
    (as)
  (fold (flip cons) nil as))

(defn always
    (v)
  (fn _ v))

(defn all?
    (t? as)
  (if
   (nil? as) true
   (t? (car as)) (all? t? (cdr as))
   false))

(defn some?
    (t? as)
  (if
   (nil? as) false
   (t? (car as)) true
   (some? t? (cdr as))))

(defn last
    (as)
  (if
    (nil? as) nil
    (nil? (cdr as)) (car as)
    (last (cdr as))))

(defn but-last
    (as)
  (cond
    (nil? as) nil
    (nil? (cdr as)) (car as)
    (but-last (cdr as))))

(defn snoc
    (as a)
  (if
   (nil? as) (list a)
   (cons (car as) (snoc (cdr as) a))))

(defn pipe
    (a b)
  (if
   (pair? b) (snoc b a)
   (list b a)))

(defx ->
    e (a . as)
  (eval e (fold pipe a as)))

(defx and
    e bs
  (all? (part eval e) bs))

(defx or
    e bs
  (some? (part eval e) bs))

(defn odds
    (cs)
  (if
   (nil? cs) nil
   (cons (car cs) (evens (cdr cs)))))

(defn evens
    (cs)
  (if
   (nil? cs) nil
   (odds (cdr cs))))

(defn len
    (as)
  (rec len (as as t 0)
    (if
     (nil? as) t
     (len (cdr as) (inc t)))))

(defn map1
    (f as)
  (if
   (nil? as) nil
   (cons (f (car as)) (map1 f (cdr as)))))

(defn each1
    (f as)
  (if
   (nil? as) nil
   (do (f (car as)) (each1 f (cdr as)))))

(defn map
    (f . as)
  (if
   (nil? as) nil
   (some? nil? as) nil
   (cons (apply f (map1 car as))
         (apply map (cons f (map1 cdr as))))))

(defn each
    (f . as)
  (if
   (nil? as) nil
   (some? nil? as) nil
   (do (apply f (map1 car as))
       (apply each (cons f (map1 cdr as))))))

(defx rec
    e (n bs . xs)
  (def e1 (ext! e))
  (eval e1 (list* defn n (odds bs) xs))
  (eval e1 (list* n (evens bs))))

(defx let
    e (bs . xs)
  (def e1 (ext! e))
  (eval e1 (list* do (map (part list def) (odds bs) (evens bs))))
  (eval e1 (list* do xs)))

(defn comp
    fs
  (if
   (nil? fs) id
   (nil? (cdr fs)) (car fs)
   (nil? (cdr (cdr fs))) (do (def f (car fs))
                             (def g (car (cdr fs)))
                             (fn (a) (f (g a))))
   (fold comp (car fs) (cdr fs))))

(def inc
  (part + 1))

(def dec
  (part (flip -) 1))

(def zero?
  (part = 0))

(def pos?
  (part < 0))

(def neg?
  (part > 0))

(defn take
    (n as)
  (if
   (zero? n) nil
   (nil? as) nil
   (cons (car as) (take (dec n) (cdr as)))))

(defn drop
    (n as)
  (if
   (zero? n) as
   (nil? as) nil
   (drop (dec n) (cdr as))))

(defn filter
    (t? as)
  (rec filter (as as rs nil)
    (if
     (nil? as) (rev rs)
     (t? (car as)) (filter (cdr as) (cons (car as) rs))
     (filter (cdr as) rs))))

(defn remove
    (t? as)
  (filter (comp not t?) as))

(defn find
    (t? as)
  (if
   (nil? as) nil
   (t? (car as)) (car as)
   (find t? (cdr as))))

(defn in?
    (a as)
  (if
    (nil? as) false
    (= a (car as)) true
    (in? a (cdr as))))

(defn take?
    (t? as)
  (rec take? (as as rs nil)
    (if
     (nil? as) (rev rs)
     (t? (car as)) (take? (cdr as) (cons (car as) rs))
     (rev rs))))

(defn drop?
    (t? as)
  (if
   (nil? as) nil
   (t? (car as)) (drop? t? (cdr as))
   as))

(defn iter
    (i f n)
  (rec iter (i i n n rs nil)
    (if
     (< n 1) (rev rs)
     (iter (f i) (dec n) (cons i rs)))))

(defn ran
    (n)
  (iter 0 inc n))

(def (fst snd trd fth)
  (iter car (fn (f) (comp f cdr)) 4))

(defn nth (n l)
  (if
   (= 0 n) (fst l)
    (= 1 n) (snd l)
    (= 2 n) (trd l)
    (= 3 n) (fth l)
    (nth (- n 3) (cdr (cdr (cdr l))))))

(def tl
  cdr)

(def hd
  car)

(defn insp
    as
  (pr as)
  (if
   (nil? as) nil
   (nil? (cdr as)) (car as)
   as))

;; TESTS

(defx time
    e as
  (let (t0 (clock)
        v  (eval e (list* do as))
        t (clock))
    (each pr as)
    (pr (q time) (/ (- t t0) 1000) (q ms))
    v))

(defx test
    e (a b)
  (let ((ax bx) (map (part eval e) (list a b)))
    (pr (q test)
        (list (q =) a b)
        (if
         (= ax bx) (q ok)
         (list (q error) ax bx)))))

;; fib
(defn fib
    (n)
  (if
   (= n 0) 0
   (= n 1) 1
   (+ (fib (- n 1)) (fib (- n 2)))))

(time (pr (fib 30)))

(test (id (+ 2 3)) 5)
(test (list* 1 2 (list 3 4)) (list 1 2 3 4))

(test (fold + 0 nil) 0)
(test (fold + 0 (list 1 2 3)) 6)
(test (fold + 10 (list 1 2 3)) 16)
(test (apply + (list 1 2 3)) 6)
(test (conc) nil)
(test (conc (list 1 2 3) nil) (list 1 2 3))

;; if
;; zero terms -> nil
;; one term evaluates to that term
;; two more terms -> if the first term is truish the second term, otherwise apply to the rest

(test (if) nil)

;; if just one term evaluates to term
;; (forall (e gen-term) (= e (if e)))
(test (if true) true)
(test (if 10) 10)
(test (if false) false)
(test (if nil) nil)

(test (if nil "true") nil)
(test (if false "true") nil)
(test (if true "true") "true")
(test (if 10 "true") "true")


(test (odds nil) nil)
(test (evens nil) nil)
(test (odds (qs 1)) (qs 1))
(test (evens (qs 1)) nil)
(test (odds (list 1 2 3 4 5 6 8)) (list 1 3 5 8))
(test (evens (list 1 2 3 4 5 6 8)) (list 2 4 6))

(defx when
    e (t? . b)
  (eval e
    (list if t? (list* do b))))

(defx unless
    e (t? . b)
  (eval e
    (list* when (list not t?) b)))


(test (when true 20 10) 10)
(test (when false 20 10) nil)
(test (unless true 20 10) nil)
(test (unless false 20 10) 10)

(test (prompt x 10) 10)
(test (prompt x 10 20) 20)
(test (+ 1 (prompt x (control x k 20))) 21)
;; (test (+ 1 (prompt x (control x1 k 20))) 21)
(test (+ 1 (prompt x (control x k 20 10))) 11)
(test (prompt x (control x k (cont? k))) true)
(test (prompt x (control x k (app? k))) true)
(test (prompt x (control x k (oper? k))) false)
(test (* 2 (prompt x (+ 1 (control x k (k 3))))) 8)
(test (* 2 (prompt x (+ 1 (control x k (k (k 3)))))) 10)
(test (* 2 (prompt x (prompt y (+ 1 (control y ky (+ 2 (control x kx (ky (kx 3))))))))) 12)

(test
 (rec recur (a (list 0 1) r nil)
   (if
    (nil? a) (rev r)
    (recur (cdr a) (cons (inc (car a)) r))))
 (list 1 2))

(test (fst nil) nil)
(test (fst (list 1 2 3 4 5)) 1)
(test (snd (list 1 2 3 4 5)) 2)
(test (trd (list 1 2 3 4 5)) 3)
(test (fth (list 1 2 3 4 5)) 4)
(test (nth 4 (list 1 2 3 4 5)) 5)
(test (nth 5 (list 1 2 3 4 5)) nil)

(test (ran 0) nil)
(test (ran 1) (list 0))
(test (ran 2) (list 0 1))
(test (ran (- 1)) nil)

(test (+) 0)
(test (+ 2) 2)
(test (+ 2 2) 4)

(test (- 2) -2)
(test (- 2 2) 0)

(test (*) 1)
(test (* 2) 2)
(test (* 2 2) 4)

(test (/ 4 1) 4)
(test (/ 4 2) 2)
(test (/ 4 3) 1)

(test (all? (part < 0) nil) true)
(test (all? (part < 0) (list 1 2 3)) true)
(test (all? (part < 0) (list 1 0 3)) false)

(test (some? (part < 0) nil) false)
(test (some? (part < 0) (list 1 2 3)) true)
(test (some? (part < 0) (list 1 0 -1)) true)

(test (and (> 1 0) (> 0 1)) false)
(test (or (> 1 0) (> 0 1)) true)

(test (let (a 1 b 2) (+ a b)) 3)
(test (let (a 1 b 2) (+ a b) 10) 10)

(test (take 0 (ran 2)) nil)
(test (take 1 (ran 2)) (list 0))
(test (take 2 (ran 2)) (list 0 1))
(test (take 3 (ran 2)) (list 0 1))

(test (drop 0 (ran 2)) (list 0 1))
(test (drop 1 (ran 2)) (list 1))
(test (drop 2 (ran 2)) nil)
(test (drop 3 (ran 2)) nil)

(test (map inc) nil)

(test (map inc (ran 3)) (list 1 2 3))
(test (map + (ran 3) (ran 4)) (list 0 2 4))
(test (map + (ran 4) (ran 3)) (list 0 2 4))

(test (find (part < 3) (ran 10)) 4)
(test (find (part < 3) (ran 3)) nil)
(test (in? 3 (ran 3)) false)
(test (in? 3 (ran 10)) true)
(test (drop? (part > 4) (ran 2)) nil)
(test (drop? (part > 4) (ran 6)) (list 4 5))
(test (take? (part > 4) (ran 6)) (list 0 1 2 3))
(test (take? (part > 4) (ran 2)) (list 0 1))
(test (len nil) 0)
(test (len (ran 20)) 20)

(test (len (ran 2)) 2)

(test (-> 3) 3)
(test (-> 3 ran) (ran 3))
(test (-> 3 ran (apply +)) (apply + (ran 3)))

(test (fst (ran 3)) 0)
(test (snd (ran 3)) 1)
(test (trd (ran 3)) 2)
(test (fth (ran 3)) nil)

(test (hd (ran 10)) (car (ran 10)))
(test (fst (ran 10)) (car (ran 10)))
(test (hd nil) (car nil))
(test (fst nil) (car nil))
