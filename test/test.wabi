(do
 (def q (fx _ (p) p))

 (def qs (fx _ p p))

  (def id (wrap q))

  (def list (wrap qs))

  (def env (fx e _ e))

(def apply
  (wrap
   (fx _ (o as)
     (eval (env) (cons o as)))))

(def list+
  (wrap
   (fx _ (a as)
     (if (pair? as)
         (cons a (list+ (car as) (cdr as)))
         a))))

(def list*
  (wrap (fx _ (a . as) (list+ a as))))

(def fn
  (fx e (as . bs)
    (wrap (eval e (list* fx _ as bs)))))

(def defx
  (fx e (n e1 as . bs)
    (eval e
      (list def n (list* fx e1 as bs)))))

(def defn
  (fx e (n as . bs)
    (eval e
      (list def n (list* fn as bs)))))

(defn fib (n)
  (if
   (< n 2) 1
   (+ (fib (- n 1)) (fib (- n 2)))))

(def t0 (clock))

(def n 28)

(pr (list (q fib) n) (fib n))

(def t (clock))

(pr "time:" (- t t0) "Âµs")

;; (pr (list (q fib) n) (fib n))

;; (defn evens
;;     (cs)
;;   (if (nil? cs) nil
;;       (cons (car cs) (odds (cdr cs)))))

;; (defn odds
;;     (cs)
;;   (if (nil? cs) nil
;;       (evens (cdr cs))))

;; (defx loop
;;     e (n bs . xs)
;;   (do
;;    (def e1 (epush e))
;;    (eval e1 (list* defn n (evens bs) xs))
;;    (eval e1 (list* n (odds bs)))))

;; ;; (loop rec (a 10)
;; ;;      (do (pr (q rec))
;; ;;          (if (<= a 0) (q ok)
;; ;;              (do (pr a) (rec (- a 1))))))

;; (defx cond
;;     e cs
;;   (loop cond (cs cs)
;;        (if (nil? cs) nil
;;            (if (nil? (cdr cs))
;;                (eval e (car cs))
;;                (if (eval e (car cs))
;;                    (eval e (car (cdr cs)))
;;                    (cond (cdr (cdr cs))))))))

;; (defx time
;;     e as
;;   (def e1 (env-push
;;   (do (def t0 (pr (clock)))
;;       (def r (pr (eval e (list* do as))))
;;       (def t (pr (clock)))
;;       (pr as)
;;       (pr "time: " (- t t0))
;;       r))
)
