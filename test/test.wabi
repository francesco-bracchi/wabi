
(def q (fx _ (p) p))


(def qs (fx _ p p))


(def id (wrap q))


(def list (wrap qs))


(def env (fx e _ e))


(def apply
  (wrap
   (fx _ (o as)
     (eval (env) (cons (unwrap o) as)))))


(def list*
  (wrap
   (fx _ (a . as)
     (if
       (nil? as) a
       (cons a (apply list* as))))))


(def fn
  (fx e (as . bs)
    (wrap (eval e (list* fx _ as bs)))))


(def defx
  (fx e (n e1 as . bs)
    (eval e
      (list def n (list* fx e1 as bs)))))


(def defn
  (fx e (n as . bs)
    (eval e
      (list def n (list* fn as bs)))))


(defn fold
    (f i as)
  (if
   (nil? as) i
   (fold f (f i (car as)) (cdr as))))


(defn conc2
    (l l0)
  (if
   (pair? l) (cons (car l) (conc2 (cdr l) l0))
   (nil? l) l0))


(defn conc
    ls
  (fold conc2 nil ls))


(defn part
    (f . as)
  (fn bs (apply f (conc as bs))))


(defn flip
    (f)
  (fn (a b . as) (apply f (list* b a as))))


(defn foldr
    (f as i)
  (if (nil? as) i
      (f (car as) (foldr f (cdr as) i))))


(defn rev
    (as)
  (fold (flip cons) nil as))


(defn always
    (v)
  (fn _ v))


(defx and
    e bs
  (all? (part eval e) bs))


(defx or
    e bs
  (some? (part eval e) bs))


(defn odds
    (cs)
  (if
   (nil? cs) nil
   (cons (car cs) (evens (cdr cs)))))


(defn evens
    (cs)
  (if
   (nil? cs) nil
   (odds (cdr cs))))


(defx loop
    e (n bs . xs)
  (def e1 (ext! e))
  (eval e1 (list* defn n (odds bs) xs))
  (eval e1 (list* n (evens bs))))


(defn comp
    fs
  (if
   (nil? fs) id
   (nil? (cdr fs)) (car fs)
   (nil? (cdr (cdr fs)))
   (do (def f (car fs))
       (def g (car (cdr fs)))
       (fn (a)
          (f (g a))))
   (fold comp (car fs) (cdr fs))))


(def inc
  (part + 1))

(def dec
  (part (flip -) 1))

(def zero?
  (part = 0))

;; (def pos?
;;   (part < 0))

;; (def neg?
;;   (part > 0))

(def fst car)

(def snd (comp car cdr))

(def trd (comp car cdr cdr))

(def fth (comp car cdr cdr cdr))

(defn nth (n l)
  (if
    (= 0 n) (fst l)
    (= 1 n) (snd l)
    (= 2 n) (trd l)
    (= 3 n) (fth l)
    (nth (dec n) (cdr l))))

;; TESTS

(defx test
    e (a b)
  (def ax (eval e a))
  (def bx (eval e b))
  (pr (q test)
      (list (q =) a b)
      (if
       (= ax bx) (q ok)
       (list (q error) ax bx))))


;; fib

(defn fib
    (n)
  (if
   (= n 0) 0
   (= n 1) 1
   (= n 2) 2
   (+ (fib (- n 1)) (fib (- n 2)))))

;; (fib 22)

(pr (env))

(def n 20)

(def t0 (clock))

(pr (list (q fib) n) (fib n))

(def t (clock))

(pr (q time) (/ (- t t0) 1000) (q ms))

;; end fib

(test (id (+ 2 3)) 5)

(test (list* 1 2 (list 3 4)) (list 1 2 3 4))


(test (fold + 0 nil) 0)

(test (fold + 0 (list 1 2 3)) 6)

(test (fold + 10 (list 1 2 3)) 16)

(test (apply + (list 1 2 3)) 6)

(test (conc) nil)

(test (conc (list 1 2 3) nil) (list 1 2 3))


;; if
;; zero terms -> nil
;; one term evaluates to that term
;; two more terms -> if the first term is truish the second term, otherwise apply to the rest

(test (if) nil)

;; if just one term evaluates to term
;; (forall (e gen-term) (= e (if e)))
(test (if true) true)
(test (if 10) 10)
(test (if false) false)
(test (if nil) nil)

(test (if nil "true") nil)
(test (if false "true") nil)
(test (if true "true") "true")
(test (if 10 "true") "true")


(test (odds nil) nil)
(test (evens nil) nil)
(test (odds (qs 1)) (qs 1))
(test (evens (qs 1)) nil)
(test (odds (list 1 2 3 4 5 6 8)) (list 1 3 5 8))
(test (evens (list 1 2 3 4 5 6 8)) (list 2 4 6))

(defx when
    e (t? . b)
  (eval e
    (list if t? (list* do b))))

(defx unless
    e (t? . b)
  (eval e
    (list* when (list not t?) b)))


(test (when true 20 10) 10)
(test (when false 20 10) nil)
(test (unless true 20 10) nil)
(test (unless false 20 10) 10)


(test (prompt x 10) 10)
(test (prompt x 10 20) 20)
(test (+ 1 (prompt x (control x k 20))) 21)
;; (test (+ 1 (prompt x (control x1 k 20))) 21)
(test (+ 1 (prompt x (control x k 20 10))) 11)
(test (prompt x (control x k (cont? k))) true)
(test (prompt x (control x k (app? k))) true)
(test (prompt x (control x k (oper? k))) false)
(test (* 2 (prompt x (+ 1 (control x k (k 3))))) 8)
(test (* 2 (prompt x (+ 1 (control x k (k (k 3)))))) 10)
(test (* 2 (prompt x (prompt y (+ 1 (control y ky (+ 2 (control x kx (ky (kx 3))))))))) 12)

(def u (list 1 2 3 4 5))

(test (fst nil) nil)
(test (fst u) 1)
(test (snd u) 2)
(test (trd u) 3)
(test (fth u) 4)
(test (nth 4 u) 5)
(test (nth 5 u) nil)

(test (loop recur (a (q (1 2 3 4)) r nil)
        (if (nil? a) (rev r)
          (recur (cdr a) (cons (inc (car a)) r))))
      (list 2 3 4 5))
