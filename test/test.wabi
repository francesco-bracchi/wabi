(def q
  (fx _ (p) p))

(def qs
  (fx _ p p))

(def id
  (wrap q))

(def list
  (wrap qs))

(def cmt
  (fx _ p :nil))

(def env
  (fx e _ e))

(def apply
  (wrap
   (fx _ (o as)
     (eval (env) (cons (unwrap o) as)))))

(def list*
  (wrap
   (fx _ (a . as)
     (if
       (= () as) a
       (cons a (apply list* as))))))

(def fn
  (fx e (as . bs)
    (wrap (eval e (list* fx _ as bs)))))


(def defx
  (fx e (n e1 as . bs)
    (eval e
      (list def n (list* fx e1 as bs)))))

(def defn
  (fx e (n as . bs)
    (eval e
      (list def n (list* fn as bs)))))

(defx prmt
    e (t . bs)
  (eval e
    (list* prompt (eval e t) bs)))

(defx ctrl
    e (t . bs)
  (eval e
    (list* control (eval e t) bs)))

(defn fold
    (f i as)
  (if
   (= () as) i
   (fold f (f i (car as)) (cdr as))))

(defn conc
    as
  (rec conc (rs () a () as as)
    (if
     (pair? a) (conc (cons (car a) rs) (cdr a) as)
     (pair? as) (conc rs (car as) (cdr as))
     (rev rs))))

(defn part
    (f . as)
  (fn bs (apply f (conc as bs))))

(defn flip
    (f)
  (fn (a b . as) (apply f (list* b a as))))

(defn foldr
    (f as i)
  (if
   (= () as) i
   (f (car as) (foldr f (cdr as) i))))

(defn rev
    (as)
  (fold (flip cons) () as))

(defn always
    (v)
  (fn _ v))

(defn all?
    (t? as)
  (if
   (= () as) :t
   (t? (car as)) (all? t? (cdr as))
   :f))

(defn some?
    (t? as)
  (if
   (= () as) :f
   (t? (car as)) :t
   (some? t? (cdr as))))

(defn last
    (as)
  (if
    (= () as) :nil
    (= () (cdr as)) (car as)
    (last (cdr as))))

(defn but-last
    (as)
  (if
    (= () as) :nil
    (= () (cdr as)) ()
    (const (car as) (but-last (cdr as)))))

(defn snoc
    (as a)
  (if
   (= () as) (list a)
   (cons (car as) (snoc (cdr as) a))))

(defn pipe
    (a b)
  (if
   (pair? b) (snoc b a)
   (list b a)))

(defx ->
    e (a . as)
  (eval e (fold pipe a as)))

(defx and
    e bs
  (all? (part eval e) bs))

(defx or
    e bs
  (some? (part eval e) bs))

(defn odds
    (cs)
  (if
   (= () cs) ()
   (cons (car cs) (evens (cdr cs)))))

(defn evens
    (cs)
  (if
   (= () cs) ()
   (odds (cdr cs))))

(defn map1
    (f as)
  (if
   (= () as) ()
   (cons (f (car as)) (map1 f (cdr as)))))

(defn each1
    (f as)
  (if
   (= () as) nil
   (do (f (car as)) (each1 f (cdr as)))))

(defn map
    (f . as)
  (if
   (= () as) ()
   (some? (part = ()) as) ()
   (cons (apply f (map1 car as))
         (apply map (cons f (map1 cdr as))))))

(defn each
    (f . as)
  (if
   (= () as) :nil
   (some? = () as) :nil
   (do (apply f (map1 car as))
       (apply each (cons f (map1 cdr as))))))

(defx rec
    e (n bs . xs)
  (def e1 (ext e))
  (eval e1 (list* defn n (odds bs) xs))
  (eval e1 (list* n (evens bs))))

(defx let
    e (bs . xs)
  (eval e (list* (list* fn (odds bs) xs) (evens bs))))

(defx letr
    e (bs . xs)
  (eval (ext e)
    (list* do
           (conc (map (part list def) (odds bs) (evens bs)) xs))))


(defn comp
    fs
  (fold (fn (f g) (fn (x) (f (g x)))) id fs))

(def inc
  (part + 1))

(def dec
  (part (flip -) 1))

(def zero?
  (part = 0))

(def one?
  (part = 1))

(def pos?
  (part < 0))

(def neg?
  (part > 0))

(def nil?
  (part = :nil))

(def ign?
  (part = _))

(defn take
    (n as)
  (if
   (zero? n) ()
   (= () as) ()
   (cons (car as) (take (dec n) (cdr as)))))

(defn drop
    (n as)
  (if
   (zero? n) as
   (= () as) ()
   (drop (dec n) (cdr as))))

(defn filter
    (t? as)
  (rec filter (as as rs ())
    (if
     (= () as) (rev rs)
     (t? (car as)) (filter (cdr as) (cons (car as) rs))
     (filter (cdr as) rs))))

(defn remove
    (t? as)
  (filter (comp not t?) as))

(defn find
    (t? as)
  (if
   (= () as) :nil
   (t? (car as)) (car as)
   (find t? (cdr as))))

;(defn in? (a as) (find (part = a) as))
(defn in?
    (a as)
  (if
    (= () as) :f
    (= a (car as)) :t
    (in? a (cdr as))))

(defn take?
    (t? as)
  (rec take? (as as rs ())
    (if
     (= () as) (rev rs)
     (t? (car as)) (take? (cdr as) (cons (car as) rs))
     (rev rs))))

(defn drop?
    (t? as)
  (if
   (= () as) ()
   (t? (car as)) (drop? t? (cdr as))
   as))

(defn iter
    (i f n)
  (rec iter (i i n n rs ())
    (if
     (< n 1) (rev rs)
     (iter (f i) (dec n) (cons i rs)))))

(defn ran
    (n)
  (iter 0 inc n))

(def (fst snd trd fth)
  (iter car (fn (f) (comp f cdr)) 4))

(defn nth (n l)
  (if
   (= 0 n) (fst l)
   (= 1 n) (snd l)
   (= 2 n) (trd l)
   (= 3 n) (fth l)
   (nth (- n 3) (cdr (cdr (cdr l))))))

(def tl
  cdr)

(def hd
  car)

(defn flat
    (a)
  (if
   (= () a) ()
   (not (pair? a)) (list a)
   (conc (-> a car flat)
         (-> a cdr flat))))

(defx when
    e (t? . bs)
  (eval e
    (list if t? (list* do bs))))

(defx unless
    e (t? . bs)
  (eval e
    (list* when (list not t?) bs)))

(defx afx
    e bs
  (eval (ext e)
    (list* defx 'me
           'env 'them
           (list (list* let '((it . _) them) bs)))))

(defx afn
    e bs
  (eval (ext e)
    (list* defn 'me
           'them
           (list (list* let '((it . _) them) bs)))))


(defn vec-update
    (v j fn . xs)
  (vec-set v j (apply fn (list* (vec-ref v j) xs))))


(defx bench
    e as
  (let (t0 (clock)
        v  (eval e (list* do as))
        t (clock))
    (list (/ (- t t0) 1000) as v)))

(defx time
    e as
  (let ((d as r) (eval e (list* bench as)))
    (pr 'benchmarks 'for)
    (each pr as)
    (pr '-------)
    (pr 'time d 'ms)
    (pr)
    r))

(defx test
    e as
  (let (asx (map (part eval e) as))
    (pr (list '= as)
        (if (apply = asx) :ok :err))))


(test (bin-len "") 0)
(test (bin-len "ciao") 4)
(test (bin-sub "ciao" 1 2) "ia")
(test (> "ciao" "ao") :f)
(test (> "ao" "ciao") :t)
(test (> "a" "") :t)
(test (< "" "a") :t)

(test (bin-sub "ciao" 0 0) "")

(test (bin-cat) "")
(test (bin-cat "") "")
(test (bin-cat "" "a") "a")
(test (bin-cat "a" "") "a")
(test (bin-cat "a" "b" "c") "abc")
(test (bin-cat "c" (bin-sub "ciao" 1 2) "o") "ciao")
(test (bin-len (bin-cat "c" (bin-sub "ciao" 1 2) "o")) 4)

(test (id (+ 2 3)) 5)
(test (list* 1 2 (list 3 4)) (list 1 2 3 4))
(test (fold + 0 ()) 0)
(test (fold + 0 (list 1 2 3)) 6)
(test (fold + 10 (list 1 2 3)) 16)
(test (apply + (list 1 2 3)) 6)

(test (conc) ())
(test (conc ()) ())
(test (conc () ()) ())
(test (conc (ran 3) (map (part + 3) (ran 3))) (ran 6))
(test (conc(ran 3)
           (map (part + 3) (ran 3))
           (map (part + 6) (ran 3)))
      (ran 9))


(test (if) :nil)

(test (if :t) :t)
(test (if 10) 10)
(test (if :f) :f)
(test (if :nil) :nil)

(test (if :nil "true") :nil)
(test (if :f "true") :nil)
(test (if :t "true") "true")
(test (if 10 "true") "true")

(test (odds ()) ())
(test (evens ()) ())
(test (odds (qs 1)) (qs 1))
(test (evens (qs 1)) ())
(test (odds (list 1 2 3 4 5 6 8)) (list 1 3 5 8))
(test (evens (list 1 2 3 4 5 6 8)) (list 2 4 6))


(test (when :t 20 10) 10)
(test (when :f 20 10) :nil)
(test (unless :t 20 10) :nil)
(test (unless :f 20 10) 10)

(test (prompt x 10) 10)
(test (prompt x 10 20) 20)
(test (+ 1 (prompt x (control x k 20))) 21)
(test (+ 1 (prompt x (control x k 20 10))) 11)
(test (prompt x (control x k (cont? k))) :t)
(test (prompt x (control x k (app? k))) :t)
(test (prompt x (control x k (oper? k))) :f)
(test (* 2 (prompt x (+ 1 (control x k (k 3))))) 8)
(test (* 2 (prompt x (+ 1 (control x k (k (k 3)))))) 10)
(test (* 2 (prompt x (prompt y (+ 1 (control y ky (+ 2 (control x kx (ky (kx 3))))))))) 12)

(test
 (rec recur (a (list 0 1) r ())
   (if
    (= () a) (rev r)
    (recur (cdr a) (cons (inc (car a)) r))))
 (list 1 2))

(test (fst :nil) :nil)
(test (fst (list 1 2 3 4 5)) 1)
(test (snd (list 1 2 3 4 5)) 2)
(test (trd (list 1 2 3 4 5)) 3)
(test (fth (list 1 2 3 4 5)) 4)
(test (nth 4 (list 1 2 3 4 5)) 5)
(test (nth 5 (list 1 2 3 4 5)) :nil)

(test (ran 0) ())
(test (ran 1) (list 0))
(test (ran 2) (list 0 1))
(test (ran (- 1)) ())

(test (+) 0)
(test (+ 2) 2)
(test (+ 2 2) 4)

(test (- 2) -2)
(test (- 2 2) 0)

(test (*) 1)
(test (* 2) 2)
(test (* 2 2) 4)

(test (/ 4 1) 4)
(test (/ 4 2) 2)
(test (/ 4 3) 1)

(test (= 10) :t)
(test (= 10 (+ 1 9)) :t)
(test (= 10 (+ 1 9) (* 2 5)) :t)
(test (= 10 (+ 1 9) (* 4 4)) :f)

(test (> 10) :t)
(test (> 20 10) :t)
(test (> 30 20 10) :t)
(test (> 30 20 21) :f)

(test (< 10) :t)
(test (< 10 20) :t)
(test (< 10 20 30) :t)
(test (< 10 20 19) :f)

(test (all? (part < 0) ()) :t)
(test (all? (part < 0) (list 1 2 3)) :t)
(test (all? (part < 0) (list 1 0 3)) :f)

(test (some? (part < 0) ()) :f)
(test (some? (part < 0) (list 1 2 3)) :t)
(test (some? (part < 0) (list 1 0 -1)) :t)

(test (and (> 1 0) (> 0 1)) :f)
(test (or (> 1 0) (> 0 1)) :t)

(test (let (a 1 b 2) (+ a b)) 3)
(test (let (a 1 b 2) (+ a b) 10) 10)

(test (take 0 (ran 2)) ())
(test (take 1 (ran 2)) (list 0))
(test (take 2 (ran 2)) (list 0 1))
(test (take 3 (ran 2)) (list 0 1))

(test (drop 0 (ran 2)) (list 0 1))
(test (drop 1 (ran 2)) (list 1))
(test (drop 2 (ran 2)) ())
(test (drop 3 (ran 2)) ())

(test (map inc) ())

(test (map inc (ran 3)) (list 1 2 3))
(test (map + (ran 3) (ran 4)) (list 0 2 4))
(test (map + (ran 4) (ran 3)) (list 0 2 4))

(test (find (part < 3) (ran 10)) 4)
(test (find (part < 3) (ran 3)) :nil)
(test (in? 3 (ran 3)) :f)
(test (in? 3 (ran 10)) :t)
(test (drop? (part > 4) (ran 2)) ())
(test (drop? (part > 4) (ran 6)) (list 4 5))
(test (take? (part > 4) (ran 6)) (list 0 1 2 3))
(test (take? (part > 4) (ran 2)) (list 0 1))
(test (len ()) 0)
(test (len (ran 20)) 20)

(test (len (ran 2)) 2)

(test (-> 3) 3)
(test (-> 3 ran) (ran 3))
(test (-> 3 ran (apply +) (* 3)) (* 3 (apply + (ran 3))))

(test (fst (ran 3)) 0)
(test (snd (ran 3)) 1)
(test (trd (ran 3)) 2)
(test (fth (ran 3)) :nil)

(test (hd (ran 10)) (car (ran 10)))
(test (fst (ran 10)) (car (ran 10)))
(test (hd :nil) (car :nil) :nil)
(test (fst :nil) (car :nil) :nil)

(test (map #(+ it 1) (ran 5)) (map inc (ran 5)))

(defn fib
    (n)
  (if (< n 2) n
      (+ (fib (- n 1))
         (fib (- n 2)))))

(test (map #(if (zero? it) 0 (one? it) 1 (+ (me (- it 1)) (me (- it 2)))) (ran 6)) (map fib (ran 6)))

(test (apply #(fold + 0 them) (ran 10)) (apply + (ran 10)))

(test (assoc {} 10 :ten) {10 :ten})
(test (map? 10) :f)
(test (map? {}) :t)
(test (map? {:a 10}) :t)
(test (map? {:a 10} :b) :f)
(test (map? {:a 10} {:b 30}) :t)
(test (dissoc {:a 10 :b 20} :a :c) {:b 20})
(test (map-len (apply hmap (ran 100))) 50)
(test (map-len (apply hmap (ran 8))) 4)

(test (hash "ciao") (hash (bin-cat "ci" "ao")))

(test {(env) 10} {(env) 10})

(test (> (list 2) (list 1)) :t)
(test (> (list 1) (list 2)) :f)

(test (pair? (list)) :f)
(test (pair? (list 1)) :t)
(test (pair? (list 1) (list 2)) :t)
(test (pair? (list 1) (list)) :f)

(test (vec-len []) 0)
(test (vec-len [1]) 1)
(test (vec-len [1 2]) 2)
(test (vec-len (apply vec (ran 33))) 33)

(test (vec? []) :t)
(test (vec? [] []) :t)
(test (vec? [] :nil) :f)

(test (push-right [] 1) [1])
(test (push-right [] 1 2) [1 2])
(test (push-right [0] 1 2) [0 1 2])

(test (push-left 1 []) [1])
(test (push-left 0 [1]) [0 1])
(test (push-left 1 []) [1])
(test (push-left 0 (apply vec (map inc (ran 32))))
      (apply vec (ran 33)))

(test (left []) :nil)
(test (left [0 1 2]) 0)
(test (left (apply vec (ran 100))) 0)

(test (right []) :nil)
(test (right [0 1 2]) 2)
(test (right (apply vec (ran 100))) 99)

(test (pop-left []) :nil)
(test (pop-left [1]) [])
(test (pop-left [1 2 3]) [2 3])

(test (pop-right []) :nil)
(test (pop-right [1]) [])
(test (pop-right [1 2 3]) [1 2])

(test (vec-ref [] 0) :nil)
(test (vec-ref [1 2 3] -1) :nil)
(test (vec-ref [1 2 3] 0) 1)
(test (vec-ref [1 2 3] 2) 3)
(test (vec-ref [1 2 3] 3) :nil)
(test (vec-ref (apply vec (ran 1000)) 500) 500)

(letr (r (ran 1000) q (apply vec r))
  (test (map #(vec-ref q it) r) r))


(test (vec-set [] 0 10) :nil)
(test (vec-ref (vec-set [1] 0 100) 0) 100)
(test (vec-ref (vec-set [0 1] 0 :zero 1 :one) 0) :zero)

(letr (rx (ran 1000) qx (apply vec rx))
    (test
     (map #(vec-ref (vec-set qx it :other) it) rx)
     (map (always :other) rx)))

(test (vec-ref (vec-update (apply vec (ran 1000)) 37 + 100) 37) 137)

(test (vec-concat [] []) [])

(test (push-right (apply vec (ran 32)) 32)
      (push-left 0 (apply vec (map inc (ran 32)))))

(test (hash (push-right (apply vec (ran 32)) 32))
      (hash (push-left 0 (apply vec (map inc (ran 32))))))

;"TODO: all data accessors accepts :nil as argument and returns :nil"
