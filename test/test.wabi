;; start

(def q
  (fx _ (p) p))

(def qs
  (fx _ p p))

(def id
  (wrap q))

(def list
  (wrap qs))

(def cmt
  (fx _ p nil))

(def env
  (fx e _ e))

(def apply
  (wrap
   (fx _ (o as)
     (eval (env) (cons (unwrap o) as)))))

(def list*
  (wrap
   (fx _ (a . as)
     (if
       (nil? as) a
       (cons a (apply list* as))))))

(def fn
  (fx e (as . bs)
    (wrap (eval e (list* fx _ as bs)))))

(def defx
  (fx e (n e1 as . bs)
    (eval e
      (list def n (list* fx e1 as bs)))))

(def defn
  (fx e (n as . bs)
    (eval e
      (list def n (list* fn as bs)))))

(defx prmt
    e (t . bs)
  (eval e
    (list* prompt (eval e t) bs)))

(defx ctrl
    e (t . bs)
  (eval e
    (list* control (eval e t) bs)))

(defn fold
    (f i as)
  (if
   (nil? as) i
   (fold f (f i (car as)) (cdr as))))

(defn conc
    as
  (rec conc (rs nil a nil as as)
    (if
     (pair? a) (conc (cons (car a) rs) (cdr a) as)
     (pair? as) (conc rs (car as) (cdr as))
     (rev rs))))

(defn part
    (f . as)
  (fn bs (apply f (conc as bs))))

(defn flip
    (f)
  (fn (a b . as) (apply f (list* b a as))))

(defn foldr
    (f as i)
  (if
   (nil? as) i
   (f (car as) (foldr f (cdr as) i))))

(defn rev
    (as)
  (fold (flip cons) nil as))

(defn always
    (v)
  (fn _ v))

(defn all?
    (t? as)
  (if
   (nil? as) true
   (t? (car as)) (all? t? (cdr as))
   false))

(defn some?
    (t? as)
  (if
   (nil? as) false
   (t? (car as)) true
   (some? t? (cdr as))))

(defn last
    (as)
  (if
    (nil? as) nil
    (nil? (cdr as)) (car as)
    (last (cdr as))))

(defn but-last
    (as)
  (cond
    (nil? as) nil
    (nil? (cdr as)) (car as)
    (but-last (cdr as))))

(defn snoc
    (as a)
  (if
   (nil? as) (list a)
   (cons (car as) (snoc (cdr as) a))))

(defn pipe
    (a b)
  (if
   (pair? b) (snoc b a)
   (list b a)))

(defx ->
    e (a . as)
  (eval e (fold pipe a as)))

(defx and
    e bs
  (all? (part eval e) bs))

(defx or
    e bs
  (some? (part eval e) bs))

(defn odds
    (cs)
  (if
   (nil? cs) nil
   (cons (car cs) (evens (cdr cs)))))

(defn evens
    (cs)
  (if
   (nil? cs) nil
   (odds (cdr cs))))

(defn map1
    (f as)
  (if
   (nil? as) nil
   (cons (f (car as)) (map1 f (cdr as)))))

(defn each1
    (f as)
  (if
   (nil? as) nil
   (do (f (car as)) (each1 f (cdr as)))))

(defn map
    (f . as)
  (if
   (nil? as) nil
   (some? nil? as) nil
   (cons (apply f (map1 car as))
         (apply map (cons f (map1 cdr as))))))

(defn each
    (f . as)
  (if
   (nil? as) nil
   (some? nil? as) nil
   (do (apply f (map1 car as))
       (apply each (cons f (map1 cdr as))))))

(defx rec
    e (n bs . xs)
  (def e1 (ext! e))
  (eval e1 (list* defn n (odds bs) xs))
  (eval e1 (list* n (evens bs))))

(defx let
    e (bs . xs)
  "evaluates the even parts of bs, and **then** creates a new environment
   and binds the results to the odd parts of bs. Then evaluates xs in the
   context of the newly created environment.

   The order is important in the continuation game, if we create
   the environmnet first, we can call a continuation only once, every
   subsequent call will try to define a symbol in an environment, that
   is a runtime error."
  (eval e (list* (list* fn (odds bs) xs) (evens bs))))

(defx letr
    e (bs . xs)
  "`letr` is like `let` except it first creates the new enviornment then
   evaluates the even parts in the context of the newly created environment.

   The order is important in the continuation game, if using letr and
   continuation, you can only continue once, since redefining a word is
   a rutime error. On the other hand letr allow local values to see all
   newly interoduced values "
  (def e1 (ext! e))
  (each (part eval e1) (map (part list def) (odds bs) (evens bs)))
  (eval e1 (list* do xs)))


;; (defn comp
;;     fs
;;   (if
;;    (nil? fs) id
;;    (nil? (cdr fs)) (car fs)
;;    (nil? (cdr (cdr fs))) (do (def f (car fs))
;;                              (def g (car (cdr fs)))
;;                              (fn (a) (f (g a))))
;;    (fold comp (car fs) (cdr fs))))

(defn comp
    fs
  (fold (fn (f g) (fn (x) (f (g x)))) id fs))

(def inc
  (part + 1))

(def dec
  (part (flip -) 1))

(def zero?
  (part = 0))

(def one?
  (part = 1))

(def pos?
  (part < 0))

(def neg?
  (part > 0))

(defn len
    (as)
  (rec len (as as t 0)
    (if
     (nil? as) t
     (len (cdr as) (inc t)))))

(defn take
    (n as)
  (if
   (zero? n) nil
   (nil? as) nil
   (cons (car as) (take (dec n) (cdr as)))))

(defn drop
    (n as)
  (if
   (zero? n) as
   (nil? as) nil
   (drop (dec n) (cdr as))))

(defn filter
    (t? as)
  (rec filter (as as rs nil)
    (if
     (nil? as) (rev rs)
     (t? (car as)) (filter (cdr as) (cons (car as) rs))
     (filter (cdr as) rs))))

(defn remove
    (t? as)
  (filter (comp not t?) as))

(defn find
    (t? as)
  (if
   (nil? as) nil
   (t? (car as)) (car as)
   (find t? (cdr as))))

(defn in?
    (a as)
  (if
    (nil? as) false
    (= a (car as)) true
    (in? a (cdr as))))

(defn take?
    (t? as)
  (rec take? (as as rs nil)
    (if
     (nil? as) (rev rs)
     (t? (car as)) (take? (cdr as) (cons (car as) rs))
     (rev rs))))

(defn drop?
    (t? as)
  (if
   (nil? as) nil
   (t? (car as)) (drop? t? (cdr as))
   as))

(defn iter
    (i f n)
  (rec iter (i i n n rs nil)
    (if
     (< n 1) (rev rs)
     (iter (f i) (dec n) (cons i rs)))))

(defn ran
    (n)
  (iter 0 inc n))

(def (fst snd trd fth)
  (iter car (fn (f) (comp f cdr)) 4))

(defn nth (n l)
  (if
   (= 0 n) (fst l)
   (= 1 n) (snd l)
   (= 2 n) (trd l)
   (= 3 n) (fth l)
   (nth (- n 3) (cdr (cdr (cdr l))))))

(def tl
  cdr)

(def hd
  car)

(defn flat
    (a)
  (if
   (nil? a) nil
   (not (pair? a)) (list a)
   (conc (-> a car flat)
         (-> a cdr flat))))

(defx when
    e (t? . bs)
  (eval e
    (list if t? (list* do bs))))

(defx unless
    e (t? . bs)
  (eval e
    (list* when (list not t?) bs)))

(defx afx
    e bs
  "this is an anamorhic fexpr, some pronouns are introduced!
  their-env -> the calling environmnet
  me -> the function itself
  them -> the arguments
  it (or @1) -> the first argument
  @2 @3 @4 @5 -> the arguments other than it"
  (eval (ext! e)
    (list* defx !me
           !their-env !them
           (list (list* let !((@1 @2 @3 @4 @5 @6 . _) them (it . _) them) bs)))))


(defx afn
    e bs
  "this is an anamorhic function, some pronouns are introduced!
  me -> the function itself
  them -> the arguments
  it (or @1) -> the first argument
  @2 @3 @4 @5 -> the arguments other than it"
  (eval (ext! e)
    (list* defn !me
           !them
           (list (list* let !((@1 @2 @3 @4 @5 @6 . _) them (it . _) them) bs)))))


(defx defp
    e (n i)
  "binds a variable to a place `(defp x 10)"
  (eval e
    (list def n (list plc i))))


(defn plc-swap
    (p f . as)
  "run the function f against the place content p until it succeeds.
   extra arguments are placed in as"
  (rec plc-swap (old (plc-val p))
    (let (new (apply f (list* old as)))
      (if
       (plc-cas p old new) new
       (plc-swap (plc-val plc))))))


(defn plc-reset
    (p v)
  (plc-swap p (always v)))


;; generics

(def gen-table (plc {}))

(defn gen
    (dfn)
  (def dmap (plc {}))
  (defn res as (apply ((plc-val dmap) (apply dfn as)) as))
  (plc-swap gen-table assoc res dmap)
  res)


(defx defg
    e (n dfn)
  (eval e
    (list def n (gen (eval e dfn)))))


(defn addm
    (g d f)
  (plc-swap ((plc-val gen-table) g) assoc d f))


(defx defm
    e (n d as . b)
  (addm (eval e n) (eval e d) (eval e (list* fn as b))))

;; generics end

(defn type
    (e)
  (if
   (plc? e) !plc
   (pair? e) !pair))

(pr (type 10))
;; (def deref (gen type))

;; (defm deref !plc
;;     (a)
;;   (plc-val a))

;; (defm deref nil
;;     (a)
;;   nil)


(defn insp
    as
  (pr as)
  (if
   (nil? as) nil
   (nil? (cdr as)) (car as)
   as))


;; TESTS

(defx bench
    e as
  (let (t0 (clock)
        v  (eval e (list* do as))
        t (clock))
    (list (/ (- t t0) 1000) as v)))

(defx time
    e as
  (let ((d as r) (apply bench as))
    (pr !benchmarks !for)
    (each pr as)
    (pr !-------)
    (pr !time d !ms)
    (pr)
    r))

(defx test
    e (a b)
  (let ((ax bx) (map (part eval e) (list a b)))
    (pr !test
        (list != a b)
        (if
         (= ax bx) !ok
         (list !error ax bx)))))

;; fib
(defn fib
    (n)
  (if
   (< n 2) n
   (+ (fib (- n 1)) (fib (- n 2)))))

(def kont
  (prmt (+ 10 20)
    (let (u (ctrl (* 2 15) k k))
      (+ u 3))))

(test (kont 10) 13)

(test (blen "") 0)
(test (blen "ciao") 4)
(test (bsub "ciao" 1 2) "ia")
(test (> "ciao" "ao") false)
(test (> "ao" "ciao") true)
(test (> "a" "") true)
(test (< "" "a") true)

(test (bsub "ciao" 0 0) "")

(test (bcat) "")
(test (bcat "") "")
(test (bcat "" "a") "a")
(test (bcat "a" "") "a")
(test (bcat "a" "b" "c") "abc")
(test (bcat "c" (bsub "ciao" 1 2) "o") "ciao")
(test (blen (bcat "c" (bsub "ciao" 1 2) "o")) 4)

(test (id (+ 2 3)) 5)
(test (list* 1 2 (list 3 4)) (list 1 2 3 4))
(test (fold + 0 nil) 0)
(test (fold + 0 (list 1 2 3)) 6)
(test (fold + 10 (list 1 2 3)) 16)
(test (apply + (list 1 2 3)) 6)

(test (conc) nil)
(test (conc nil) nil)
(test (conc nil nil) nil)
(test (conc (ran 3) (map (part + 3) (ran 3))) (ran 6))
(test (conc(ran 3)
           (map (part + 3) (ran 3))
           (map (part + 6) (ran 3)))
      (ran 9))


;; if
;; zero terms -> nil
;; one term evaluates to that term
;; two more terms -> if the first term is truish the second term, otherwise apply to the rest
(test (if) nil)

;; if just one term evaluates to term
;; (forall (e gen-term) (= e (if e)))
(test (if true) true)
(test (if 10) 10)
(test (if false) false)
(test (if nil) nil)

(test (if nil "true") nil)
(test (if false "true") nil)
(test (if true "true") "true")
(test (if 10 "true") "true")


(test (odds nil) nil)
(test (evens nil) nil)
(test (odds (qs 1)) (qs 1))
(test (evens (qs 1)) nil)
(test (odds (list 1 2 3 4 5 6 8)) (list 1 3 5 8))
(test (evens (list 1 2 3 4 5 6 8)) (list 2 4 6))


(test (when true 20 10) 10)
(test (when false 20 10) nil)
(test (unless true 20 10) nil)
(test (unless false 20 10) 10)

(test (flat nil) nil)
(test (flat !(a . d)) !(a d))
(test (flat !(((a)))) !(a))
(test (flat !((a b) (c d))) !(a b c d))

(test (prompt x 10) 10)
(test (prompt x 10 20) 20)
(test (+ 1 (prompt x (control x k 20))) 21)
;; (test (+ 1 (prompt x (control x1 k 20))) 21)
(test (+ 1 (prompt x (control x k 20 10))) 11)
(test (prompt x (control x k (cont? k))) true)
(test (prompt x (control x k (app? k))) true)
(test (prompt x (control x k (oper? k))) false)
(test (* 2 (prompt x (+ 1 (control x k (k 3))))) 8)
(test (* 2 (prompt x (+ 1 (control x k (k (k 3)))))) 10)
(test (* 2 (prompt x (prompt y (+ 1 (control y ky (+ 2 (control x kx (ky (kx 3))))))))) 12)

(test
 (rec recur (a (list 0 1) r nil)
   (if
    (nil? a) (rev r)
    (recur (cdr a) (cons (inc (car a)) r))))
 (list 1 2))

(test (fst nil) nil)
(test (fst (list 1 2 3 4 5)) 1)
(test (snd (list 1 2 3 4 5)) 2)
(test (trd (list 1 2 3 4 5)) 3)
(test (fth (list 1 2 3 4 5)) 4)
(test (nth 4 (list 1 2 3 4 5)) 5)
(test (nth 5 (list 1 2 3 4 5)) nil)

(test (ran 0) nil)
(test (ran 1) (list 0))
(test (ran 2) (list 0 1))
(test (ran (- 1)) nil)

(test (+) 0)
(test (+ 2) 2)
(test (+ 2 2) 4)

(test (- 2) -2)
(test (- 2 2) 0)

(test (*) 1)
(test (* 2) 2)
(test (* 2 2) 4)

(test (/ 4 1) 4)
(test (/ 4 2) 2)
(test (/ 4 3) 1)

(test (= 10) true)
(test (= 10 (+ 1 9)) true)
(test (= 10 (+ 1 9) (* 2 5)) true)
(test (= 10 (+ 1 9) (* 4 4)) false)

(test (> 10) true)
(test (> 20 10) true)
(test (> 30 20 10) true)
(test (> 30 20 21) false)

(test (< 10) true)
(test (< 10 20) true)
(test (< 10 20 30) true)
(test (< 10 20 19) false)

(test (all? (part < 0) nil) true)
(test (all? (part < 0) (list 1 2 3)) true)
(test (all? (part < 0) (list 1 0 3)) false)

(test (some? (part < 0) nil) false)
(test (some? (part < 0) (list 1 2 3)) true)
(test (some? (part < 0) (list 1 0 -1)) true)

(test (and (> 1 0) (> 0 1)) false)
(test (or (> 1 0) (> 0 1)) true)

(test (let (a 1 b 2) (+ a b)) 3)
(test (let (a 1 b 2) (+ a b) 10) 10)

(test (take 0 (ran 2)) nil)
(test (take 1 (ran 2)) (list 0))
(test (take 2 (ran 2)) (list 0 1))
(test (take 3 (ran 2)) (list 0 1))

(test (drop 0 (ran 2)) (list 0 1))
(test (drop 1 (ran 2)) (list 1))
(test (drop 2 (ran 2)) nil)
(test (drop 3 (ran 2)) nil)

(test (map inc) nil)

(test (map inc (ran 3)) (list 1 2 3))
(test (map + (ran 3) (ran 4)) (list 0 2 4))
(test (map + (ran 4) (ran 3)) (list 0 2 4))

(test (find (part < 3) (ran 10)) 4)
(test (find (part < 3) (ran 3)) nil)
(test (in? 3 (ran 3)) false)
(test (in? 3 (ran 10)) true)
(test (drop? (part > 4) (ran 2)) nil)
(test (drop? (part > 4) (ran 6)) (list 4 5))
(test (take? (part > 4) (ran 6)) (list 0 1 2 3))
(test (take? (part > 4) (ran 2)) (list 0 1))
(test (len nil) 0)
(test (len (ran 20)) 20)

(test (len (ran 2)) 2)

(test (-> 3) 3)
(test (-> 3 ran) (ran 3))
(test (-> 3 ran (apply +) (* 3)) (* 3 (apply + (ran 3))))

(test (fst (ran 3)) 0)
(test (snd (ran 3)) 1)
(test (trd (ran 3)) 2)
(test (fth (ran 3)) nil)

(test (hd (ran 10)) (car (ran 10)))
(test (fst (ran 10)) (car (ran 10)))
(test (hd nil) (car nil))
(test (fst nil) (car nil))

(fib 20)

;; (pr (kont 100))

(test (map #(+ it 1) (ran 5)) (map inc (ran 5)))

(test (map #(if (zero? it) 0 (one? it) 1 (+ (me (- it 1)) (me (- it 2)))) (ran 6)) (map fib (ran 6)))

(test (apply #(fold + 0 them) (ran 10)) (apply + (ran 10)))

(test (fold #(+ @1 @2) 0 (ran 10)) (fold + 0 (ran 10)))

(test (#(id @3) 10) nil)

(test (assoc {} 10 !ten) {10 !ten})
(test (map? 10) false)
(test (map? {}) true)
(test (map? {!a 10}) true)
(test (map? {!a 10} !b) false)
(test (map? {!a 10} {!b 30}) true)
(test (dissoc {!a 10 !b 20} !a !c) {!b 20})
(test (map-len (apply hmap (ran 100))) 50)
(test (map-len (apply hmap (ran 8))) 4)

;;; tentave compiling, inlining constant values
(def good-special-forms (list if do prompt control))

(defn compile-expr
    (e ps x)
  (rec compile (x x)
    (if
     (and (sym? x) (in? x ps)) x
     (sym? x) (eval e x)
     (not (pair? x)) x
     (let (a (compile (car x)))
       (cons a
             (if
              (app? a) (map compile (cdr x))
              (in? a good-special-forms) (map compile (cdr x))
              (cdr x)))))))

(defn compile-combiner!
    (c)
  (letr (e  (combiner-static-env c)
         bs (combiner-body c)
         en (combiner-caller-env-name c)
         ps (combiner-parameters c)
         ss (filter sym? (flat (cons en ps))))
    (combiner-compiled-body-set! c (map (part compile-expr e ss) bs))))


(compile-combiner! fib)

;; (time (each (fn (_) (fib 25)) (ran 40)))

(test (hash "ciao") (hash (bcat "ci" "ao")))

(test {(env) 10} {(env) 10})

(test (> (list 2) (list 1)) true)
(test (> (list 1) (list 2)) false)

(test (kont 100) 103)

;; (time (each #(fib 24) (ran 100)))

;; (time (fib 35))

(test
 110
 (let ()
   (defp x 10)
   (plc-swap x + 100)
   (plc-val x)))

(test (plc-reset (plc 10) 20) 20)


(test (pair? (list)) false)
(test (pair? (list 1)) true)
(test (pair? (list 1) (list 2)) true)
(test (pair? (list 1) (list)) false)

;; (test (pop-left []) nil)
;; (test (pop-left [1]) [])
;; (test (pop-left [0 1]) [0])
;; (test (pop-left (apply deq (ran 100)))
;;       (apply deq (map inc (ran 99))))

;; (test (pop-right []) nil)
;; (test (pop-right [1]) [])
;; (test (pop-right [0 1]) [1])
;; (test (pop-left (apply deq (ran 100)))
;;       (apply deq (ran 99)))

;; (pr (deq-concat (apply deq (ran 100))
;;                 (apply deq (map (part + 100) (ran 100)))))

;; ;; (test [] [])
;; ;; (test [0] [0])

;; ;; (pr [])
;; ;; (pr [1])

;; (pr [0 10 20 30 40 50 60])


;; (defn deq-to-list
;;     (d)
;;   (rec deq-to-list (d d r nil)
;;     (if
;;      (deq-emp? d) r
;;      (deq-to-list (pop-right d) (cons (right d) r)))))


;; (pr (deq-to-list [0 1 2 3 4 5 6 7 8 9 10]))


;; ;; (time (fib 37))


(test (deq-len []) 0)
(test (deq-len [1]) 1)
(test (deq-len [1 2]) 2)
(test (deq-len (apply deq (ran 33))) 33)

(test (deq? []) true)
(test (deq? [] []) true)
(test (deq? [] nil) false)

(test (deq-emp?) true)
(test (deq-emp? []) true)
(test (deq-emp? [1]) false)
(test (deq-emp? 10) false)
(test (deq-emp? [] []) true)
(test (deq-emp? [] [1]) false)

(test (push-right [] 1) [1])
(test (push-right [] 1 2) [1 2])
(test (push-right [0] 1 2) [0 1 2])

(test (push-left 1 []) [1])
(test (push-left 0 [1]) [0 1])
(test (push-left 1 []) [1])
(test (push-left 0 (apply deq (map inc (ran 32))))
      (apply deq (ran 33)))


(test (left []) nil)
(test (left [0 1 2]) 0)
(test (left (apply deq (ran 100))) 0)

(test (right []) nil)
(test (right [0 1 2]) 2)
(test (right (apply deq (ran 100))) 99)

(test (pop-left []) nil)
(test (pop-left [1]) [])
(test (pop-left [1 2 3]) [2 3])

(test (pop-right []) nil)
(test (pop-right [1]) [])
(test (pop-right [1 2 3]) [1 2])

;; (test (deq-concat [] []) [])

;; (def xxxx (apply deq (ran 1000)))

;; (pr (fib 20))
;; (pr !fib)
;; (pr (ran 100))
;; (pr xxxx)

;; (pr (list (apply deq (ran 100)) (apply deq (ran 96))))

;; (pr x)
;; (pr (deq-concat (apply deq (ran 100)) (apply deq (ran 96))))


;; (test (map (fn (xs) (left (apply deq (ran (inc xs))))) (ran 27))
;;       (map (always 0) (ran 27)))

;; (test (map (fn (xs) (right (apply deq (ran (inc xs))))) (ran 27))
;;       (ran 27))
